<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Qianmeng&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Qianmeng's Blog">
<meta property="og:url" content="http://qianmengchen.github.io/blog/index.html">
<meta property="og:site_name" content="Qianmeng's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qianmeng's Blog">
<meta name="twitter:description">
  
    <link rel="alternate" href="atom.xml" title="Qianmeng&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Qianmeng&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/blog">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://qianmengchen.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-P2POnSocialNorm-simulation1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/11/P2POnSocialNorm-simulation1/" class="article-date">
  <time datetime="2016-04-11T11:35:00.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/11/P2POnSocialNorm-simulation1/">P2POnSocialNorm_simulation1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一个简单的模拟"><a href="#一个简单的模拟" class="headerlink" title="一个简单的模拟"></a>一个简单的模拟</h2><p>背景：</p>
<p>在一个DTN中，假设每个人都可以提供某种服务或者接受别人的服务。当俩节点相遇时，一方发出request，另一方可以选择serve或者不serve。现设计一种机制，使得网络中所有参与者都愿意在接收到他人请求时进行serve，避免出现free rider（即只获取服务不分享服务的人）。该机制如下：</p>
<ol>
<li>每个人都有一个全局可知的reputation。</li>
<li>只有当双方的reputation都超过一个threshold时，双方才可以进行服务。</li>
<li>如果出现了free rider情况，该free rider的reputation将被降为0。</li>
<li>遵守规矩的人，reputation将随着时间增加，但reputation存在上限。</li>
<li>要考虑因为网络连接错误的可能，即有一定概率服务者提供了服务而请求者没有收到。</li>
<li>要考虑因为系统问题，有人被错误地判断为了free rider。</li>
<li>当然，对他人服务是要有一定代价的，此外，人对未来可获取价值的期望的在意程度也不一样。</li>
</ol>
<p>此处的基础模拟暂时不考虑很多因素。首先是，假定网络中每个人都愿意进行serve，因此reputation被降的情况只因为系统错误。此外，尽管每个人相遇后进行serve的utility虽然会进行计算，但是不会实际对模拟结果造成影响。</p>
<p>模拟程序python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the reward: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	reward = int(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	reward = <span class="number">10</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set reward to default 10"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the cost: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	cost = int(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	cost = <span class="number">2</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set cost to default 2"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the upper limit of reputation: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	L = int(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	L = <span class="number">20</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set L to default 20"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the threshold of reputation: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	h0 = int(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	h0 = int(L*<span class="number">0.5</span>)</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set h0 to default "</span>+str(h0)</span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the number of peers: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	num = <span class="number">20</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set num to default 20"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the probability of connectivity error: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	varepsilon = float(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	varepsilon = <span class="number">0.05</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set varepsilon to default 0.05"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the probability of false punishment: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	alpha = float(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	alpha = <span class="number">0.01</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set alpha to default 0.01"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the probability of encounter: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	encounterProb = float(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	encounterProb = <span class="number">0.02</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set encounterProb to default 0.02"</span></span><br><span class="line"></span><br><span class="line">s = raw_input(<span class="string">"Please input the time duration of simulation: "</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	ticks = int(s)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	ticks = <span class="number">3000</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"set ticks to default 3000"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">peer</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.reputation = <span class="number">0</span></span><br><span class="line">		self.utility = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## set \lambda*b to 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(server, client)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> server.reputation &gt;= h0 <span class="keyword">and</span> client.reputation &gt;= h0:</span><br><span class="line">		server.utility = server.utility - cost</span><br><span class="line">		random.seed()</span><br><span class="line">		success = random.random()</span><br><span class="line">		<span class="keyword">if</span>(success &gt;= varepsilon):</span><br><span class="line">			client.utility = client.utility + (reward - cost)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			client.utility = client.utility - cost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allPeers = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">	allPeers.append(peer())</span><br><span class="line"></span><br><span class="line">plot = [[<span class="number">0</span> <span class="keyword">for</span> t <span class="keyword">in</span> range(ticks+<span class="number">1</span>)] <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>)]</span><br><span class="line">ratio = [<span class="number">0.0</span> <span class="keyword">for</span> t <span class="keyword">in</span> range(ticks+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">theory = [[<span class="number">0.0</span> <span class="keyword">for</span> t <span class="keyword">in</span> range(ticks+<span class="number">1</span>)] <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>)]</span><br><span class="line">theory[<span class="number">0</span>][<span class="number">0</span>] = num;</span><br><span class="line">Theory_active = [<span class="number">0.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(ticks+<span class="number">1</span>)]</span><br><span class="line">Theory_active[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">Theory_ratio = [<span class="number">0.0</span> <span class="keyword">for</span> t <span class="keyword">in</span> range(ticks+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(ticks+<span class="number">1</span>):</span><br><span class="line">	distribution = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> someone <span class="keyword">in</span> allPeers:</span><br><span class="line">		random.seed()</span><br><span class="line">		prob = random.random()</span><br><span class="line">		<span class="keyword">if</span> prob &lt; encounterProb:</span><br><span class="line">			objID = random.randint(<span class="number">0</span>, num<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">while</span> allPeers[objID] <span class="keyword">is</span> someone:</span><br><span class="line">				objID = random.randint(<span class="number">0</span>, num<span class="number">-1</span>)</span><br><span class="line">			serve(allPeers[objID], someone)</span><br><span class="line">		<span class="keyword">if</span> someone.reputation &lt; h0:</span><br><span class="line">			someone.reputation = someone.reputation + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			fail = random.random()</span><br><span class="line">			<span class="keyword">if</span> fail &lt; alpha:</span><br><span class="line">				someone.reputation = <span class="number">0</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				someone.reputation = min(L, someone.reputation + <span class="number">1</span>)</span><br><span class="line">		distribution[someone.reputation] = distribution[someone.reputation] + <span class="number">1</span></span><br><span class="line">	activeNum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(h0, L+<span class="number">1</span>):</span><br><span class="line">		activeNum = activeNum + distribution[i]</span><br><span class="line">	percent = int(t / float(ticks) * <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Progress %d %% \r"</span> %percent,</span><br><span class="line">	<span class="comment">#print distribution</span></span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>):</span><br><span class="line">		plot[x][t] = distribution[x]</span><br><span class="line">	<span class="keyword">if</span> t &gt;= <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>):</span><br><span class="line">			<span class="keyword">if</span> x == L:</span><br><span class="line">				theory[x][t] = (<span class="number">1</span>-alpha)*theory[x][t<span class="number">-1</span>] + (<span class="number">1</span>-alpha)*theory[x<span class="number">-1</span>][t<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">elif</span> x &gt;= h0+<span class="number">1</span>:</span><br><span class="line">				theory[x][t] = (<span class="number">1</span>-alpha)*theory[x<span class="number">-1</span>][t<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">elif</span> x &gt;= <span class="number">1</span>:</span><br><span class="line">				theory[x][t] = theory[x<span class="number">-1</span>][t<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				theory[x][t] = alpha*Theory_active[t<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span> x &gt;= h0:</span><br><span class="line">				Theory_active[t] = Theory_active[t] + theory[x][t]</span><br><span class="line">		</span><br><span class="line">	Theory_ratio[t] = Theory_active[t]/float(num)</span><br><span class="line">	ratio[t] = activeNum/float(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">" "</span>*<span class="number">20</span> + <span class="string">"\r"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Complete!"</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.title(<span class="string">"Distribution"</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>):</span><br><span class="line">	plt.plot(plot[x], label = str(x))</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, ticks, <span class="number">0</span>, L+<span class="number">1</span>])</span><br><span class="line">plt.ylabel(<span class="string">'Number'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(ratio)</span><br><span class="line">plt.title(<span class="string">"Ratio"</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Active Ratio'</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, ticks, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.title(<span class="string">"Theoretical Distribution"</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, L+<span class="number">1</span>):</span><br><span class="line">	plt.plot(theory[x], label = str(x))</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Number'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(Theory_ratio)</span><br><span class="line">plt.title(<span class="string">"Theoretical Ratio"</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Active Ratio'</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, ticks, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.close(<span class="string">'all'</span>)</span><br></pre></td></tr></table></figure>
<p>几组运行结果如下：</p>
<ul>
<li>使用全部default设定：</li>
</ul>
<p><img src="/blog/images/test3K_simu.png" alt="此处本该是图片"></p>
<p><img src="/blog/images/test3k_theo.png" alt="此处本该是图片"></p>
<ul>
<li><p>仅将时间延长到10000</p>
<p><img src="/images/test10k_simu.png" alt="此处本该是图片"></p>
<p><img src="/images/test10k_theo.png" alt="此处本该是图片"></p>
</li>
<li><p>时间仍然为10000，threshold调为15 (75% limit)</p>
<p><img src="/images/test10k_simu_15th.png" alt="此处本该是图片"></p>
<p><img src="/images/test10k_theo_15th.png" alt="此处本该是图片"></p>
</li>
<li><p>将系统出错概率调整为0.0000001</p>
<p><img src="/images/test3k_simu_e-7.png" alt="此处本该是图片"></p>
<p><img src="/images/test3k_theo_e-7.png" alt="此处本该是图片"></p>
<p>虽然理论上还要再分析一下之类的。。。但是现在懒癌犯了，下次再补吧。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/04/11/P2POnSocialNorm-simulation1/" data-id="cimvy2ect0006c4xti0j08jxk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CS35L-March-28th" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/CS35L-March-28th/" class="article-date">
  <time datetime="2016-03-28T22:20:12.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/CS35L-March-28th/">CS35L March 28th</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Warning: DO NOT run commands like <strong>su</strong> and <strong>sudo</strong> on SEASNET</p>
<ol>
<li>GNU/Linux</li>
</ol>
<p>Linux is only the <strong>Kernel</strong> of an operating system</p>
<p><strong>Which Linux?</strong></p>
<p>Ubuntu Linux Distribution:</p>
<ul>
<li>Most popular as of 2015 for personal use</li>
<li>Frequently updated, fixed release cycle</li>
<li>Simple installation and booting</li>
<li>Nice set of pre-installed packages</li>
</ul>
<p>Connect to Linux server:</p>
<p>ssh username@lnxsrv.seas.ucla.edu<br>password</p>
<h2 id="Files-and-Processes"><a href="#Files-and-Processes" class="headerlink" title="Files and Processes"></a><a href="#Files_and_Processes" title="Files and Processes"></a>Files and Processes</h2><p>Everything is either a <strong>process</strong> or a <strong>file</strong>:</p>
<ul>
<li>Process: an executing program identified by PID</li>
<li>File:</li>
</ul>
<h3 id="The-Basics-Moving-Around"><a href="#The-Basics-Moving-Around" class="headerlink" title="The Basics: Moving Around"></a><a href="#The_Basics_3A_Moving_Around" title="The Basics: Moving Around"></a>The Basics: Moving Around</h3><ul>
<li>pwd: print working directory</li>
<li><p>cd: change directory</p>
<pre><code>*   ~: home
</code></pre><ul>
<li>.: current directory</li>
<li>/: root directory, or directory separator</li>
<li>..: parent directory</li>
</ul>
</li>
</ul>
<h3 id="The-Basics-Dealing-with-Files"><a href="#The-Basics-Dealing-with-Files" class="headerlink" title="The Basics: Dealing with Files"></a><a href="#The_Basics_3A_Dealing_with_Files" title="The Basics: Dealing with Files"></a>The Basics: Dealing with Files</h3><ul>
<li>mv: move/rename a file</li>
<li>cp: copy a file</li>
<li><p>rm: remove a file</p>
<pre><code>*   -r: remove directories and their contents recursively
</code></pre></li>
<li><p>mkdir: make a directory</p>
</li>
<li>rmdir: remove an empty directory</li>
<li><p>ls: list contents of a directory</p>
<pre><code>*   -a: list all files including hidden ones
</code></pre><ul>
<li>-l: show long listing including permission info</li>
<li>-d: list directories</li>
</ul>
</li>
</ul>
<h3 id="Linux-File-Permissions"><a href="#Linux-File-Permissions" class="headerlink" title="Linux File Permissions"></a><a href="#Linux_File_Permissions" title="Linux File Permissions"></a>Linux File Permissions</h3><ul>
<li><p>chmod</p>
<pre><code>*   read(r), write(w), executable(x)
</code></pre><ul>
<li>user, group, others</li>
<li>-u: user, the owner of the file</li>
<li>-g: group, users who are members of the file’s group</li>
<li>-o: others, users who are not the owner of the file or members of the group</li>
<li>-a: all, all three of the above, is the same as <em>-ugo</em>*   ugo, each contains three bits: rwxrw—x(rwx for u, rw for g and x for o, also written as 111110001 or 761)</li>
<li><strong>eg: chmod g+w README</strong> add w permission for g</li>
<li><strong>eg: chmod o-r README</strong> deprive r permission of o</li>
<li><strong>eg: chmod g=rx README</strong> g has permissiin of r and x</li>
<li>(= “chmod g - w README” <strong>and</strong> “chmod g + x README” )</li>
</ul>
</li>
</ul>
<h3 id="The-Basics-Changing-File-Attributes"><a href="#The-Basics-Changing-File-Attributes" class="headerlink" title="The Basics: Changing File Attributes"></a><a href="#The_Basics_3A_Changing_File_Attributes" title="The Basics: Changing File Attributes"></a>The Basics: Changing File Attributes</h3><ul>
<li><p>ln: create a link</p>
<pre><code>*   Hard links: point to physical data
</code></pre><ul>
<li>Soft links aka symbolic links (-s): point to a file</li>
</ul>
</li>
<li><p>touch: update access &amp; modification time to current time</p>
</li>
</ul>
<h3 id="The-Basics-find"><a href="#The-Basics-find" class="headerlink" title="The Basics: find"></a><a href="#The_Basics_3A_find" title="The Basics: find"></a>The Basics: find</h3><ul>
<li>-type: type of a file(eg: directory, symbolic link)</li>
<li>-perm: permission of a file</li>
<li>-name: name of a file</li>
<li>-user: owner of a file</li>
<li>-maxdepth: how many levels to search</li>
<li><strong>eg: find . -name hwk1 -type d -perm 761 -user qianmeng -maxdepth 1</strong>(1 means current directory only)</li>
</ul>
<h3 id="The-Basics-whereis"><a href="#The-Basics-whereis" class="headerlink" title="The Basics: whereis"></a><a href="#The_Basics_3A_whereis" title="The Basics: whereis"></a>The Basics: whereis</h3><ul>
<li>locate the binary file</li>
</ul>
<h3 id="Manual-man"><a href="#Manual-man" class="headerlink" title="Manual(man)"></a><a href="#Manual_28man_29" title="Manual(man)"></a>Manual(man)</h3><ul>
<li>Extensive documentation that comes preinstalled with almost all substantial Unix and Unix-like operating systems</li>
<li><p>Usage</p>
<pre><code>*   read a manual page for a Linux command

    - man &amp;lt;command_name&amp;gt;
</code></pre><ul>
<li>man section command_name</li>
<li>Hit &quot;q&quot; to get out of man page</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/CS35L-March-28th/" data-id="cimvy2ecl0001c4xtlbyjzb00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CS-35L/">CS 35L</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SEDUM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/SEDUM/" class="article-date">
  <time datetime="2016-03-28T22:18:45.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/SEDUM/">SEDUM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Exploiting-Social-Networks-in-Utility-Based-Distributed-Routing-for-DTNs"><a href="#Exploiting-Social-Networks-in-Utility-Based-Distributed-Routing-for-DTNs" class="headerlink" title="Exploiting Social Networks in Utility-Based Distributed Routing for DTNs"></a><a href="#Exploiting_Social_Networks_in_Utility-Based_Distributed_Routing_for_DTNs" title="Exploiting Social Networks in Utility-Based Distributed Routing for DTNs"></a>Exploiting Social Networks in Utility-Based Distributed Routing for DTNs</h2><p>The probability that at least one copy is sent to the destination node (P) is<br>$P = 1 - (1 - P_{(S,D)})^{N<em>C}$<br>Here $P</em>{(S,D)}$ is the probability for message to be transmitted from the source to the destination, and each message can have $N_C$ copies.</p>
<p>思路：<br>可证得：随着$N<em>C$的线性增长，overhead也线性增长，而delay只有negligible的减少。所以目标在提升$P</em>{(S,D)}$ </p>
<p>传递策略：</p>
<ol>
<li>传递的第一个阶段为Replicating Phase，消息从源头向相遇节点拷贝一定数量次。</li>
<li>第二个阶段为Forwarding Phase，每个持有消息的节点总是将消息传递给Utility比自己高的节点。</li>
<li>第三个阶段为Clearing Phase，在某消息完成传递之后，通知系统内其他节点丢弃该消息。</li>
</ol>
<p>Utility定义：</p>
<ol>
<li>定义direct duration为$\hat{U}<em>{(i, j)} = (\sum\limits</em>{k=1}^{K}t_{(i, j)(k)})/T$</li>
<li>定义indirect duration为$\tilde{U}<em>{(i, j)} = \hat{U}</em>{(i, k)}*\hat{U}_{(k, j)}$</li>
<li>最终定义Utility为$U<em>{(i, j)} = max(\hat{U}</em>{(i ,j)}, max(\tilde{U}_{(i, j)}))$</li>
<li>此外，Utility需要每隔一段时间进行更新，获得新的Utility之后可以通过如下方式计算所采取的Utility：<br>$U<em>{(i, j)} = \gamma U</em>{(i, j)} + (1 - \gamma)U<em>{(i, j)</em>{old}}, \gamma \in (0, 1)$</li>
</ol>
<p>拷贝方式：<br>Optimal Tree Replication Algorithm:<br>如果每个初始节点允许存有的拷贝数为$N_C$，那么它的responsibility为$N_C－1$。每次遇到需要传递的节点，它将自己responsibility的一半传递给对方，自己继续发放剩下的部分。收到拷贝的节点重复该行为。该算法的时间复杂度和Binary Tree Replication Algorithm同为$log_2 N_C$</p>
<p><strong>Buffer Management:</strong></p>
<ol>
<li>关于消息在Buffer中的排列：<br>先分priority，priority高的先处理。同priority中根据接受时间递增排列，以保证停留时间长的先传递出去。</li>
<li>如何处理Buffer Congestion：<br>消息源节点创建一定量其消息的core-replica然后传递给周围utility高的节点。core-replica不能被替换掉，但是可以把non-core-replica替换。对于同为non-core-replica的情况，utility高的消息可以把低的消息置换出来。</li>
<li>如何删除意境传递成功的消息：<br>每个节点都会存一个deliveredMsgList，每当一个消息传递成功时，就更新这两个节点的list。每当两个节点相遇时，双方合并list，然后检查并删除成功的消息。</li>
</ol>
<p>反思：<br>这是一篇讨论utility的文章，然而考虑到utility的实用性问题，暂抛开这个问题不谈。这篇文章对我而言有这样几个点值得注意，一个是optimal tree replication algorithm，一个是buffer management。</p>
<p>replication这一块，之前一直默认的是binary tree replication是最优方案，甚至当时我看paper时，看到optimal tree的模式也以为和binary tree是一个东西只是换了个名字。然而这篇paper提出optimal tree replication效率比binary tree高，因为replication delay比较短（蛤？）从算法的角度来说这两种方法应该是一样的，所以并不理解这个效率的提高来自哪。</p>
<p>buffer management的主要启发是core-replica的设置，这种方法使一个消息不会因为时间久远而灭绝在网络中。此外deliveredMsgList乍一看对效率提升有帮助，但是其实和普通的spread deleting message是一个效果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/SEDUM/" data-id="cimvy2edn000lc4xtdq33niaz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PeopleRank" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/PeopleRank/" class="article-date">
  <time datetime="2016-03-28T22:18:38.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/PeopleRank/">PeopleRank</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Social-Opportunistic-Forwarding"><a href="#Social-Opportunistic-Forwarding" class="headerlink" title="Social Opportunistic Forwarding"></a><a href="#Social_Opportunistic_Forwarding" title="Social Opportunistic Forwarding"></a>Social Opportunistic Forwarding</h1><p><em>The idea</em><br>A node u forwards data to a node v that it meets if the rank of v is higher than the rank of u</p>
<p><em>Centralized PeopleRank</em><br>We denote the social graph $G_S = (V_S, E_S)$ as a finite undirected graph with a vertex set V and an edge set $E_S$. An edge $(u, v) \in E_s$ if and only if there is a social relation between nodes u and v. Here we define a social relationship between two nodes u and v either (i) if they are declared friends, or (ii) if they are sharing k common interests.<br>$PeR(N<em>i) = (1-d) + d\sum\limits</em>{N_j \in F(N_j)}\frac{PeR(N_j)}{\left|F(N_j)\right|}$<br>where $N_i$ is the node, $F(N_i)$ is the set of neighbors that links to $N_i$ and d is the damping factor which is defined as the probability at any encounter, that the social relation between the nodes helps to improve the rank of these nodes.<br>Algorithm: Distributed PeopleRank</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Require: |F(i) &gt;= <span class="number">0</span>|</span><br><span class="line">PeR(i) = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> true do:</span><br><span class="line">    <span class="keyword">while</span> i <span class="keyword">is</span> <span class="keyword">in</span> contact <span class="keyword">with</span> j:</span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">in</span> F(i):</span><br><span class="line">            send(PeR(i), |F(i)|)</span><br><span class="line">            receive(PeR(j), |F(j)|)</span><br><span class="line">            update(PeR(i))</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> buffer(i):</span><br><span class="line">            <span class="keyword">if</span> PeR(j) &gt;= PeR(i) </span><br><span class="line">            <span class="keyword">or</span> j == destination(m):</span><br><span class="line">                forward(m, j)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/PeopleRank/" data-id="cimvy2edd000ic4xtozkmuzrd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Multi-hop-vs-Two-hop-Routing-Modeling-Simulation-in-DTN" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/Multi-hop-vs-Two-hop-Routing-Modeling-Simulation-in-DTN/" class="article-date">
  <time datetime="2016-03-28T22:18:33.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/Multi-hop-vs-Two-hop-Routing-Modeling-Simulation-in-DTN/">Multi-hop vs Two-hop Routing Modeling &amp; Simulation in DTN</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Important: </strong> compute the average delay of one-copy-two-hop routing scheme:<br>$E(T<em>{s, d}) = \frac{1}{\lambda</em>{s, d}+\sum<em>{i \in \Omega}\lambda</em>{s, i}} + \sum<em>{i \in \Omega}\frac{\lambda</em>{s, i}}{\lambda<em>{s, d} + \sum</em>{i \in \Omega}\lambda<em>{s, i}}\frac{1}{\lambda</em>{s, d} + \lambda<em>{i, d}} = \sum</em>{i \in \Omega’}\frac{\lambda_{s, i}}{s\Omega’}\frac{1}{\mu_i}$</p>
<p>$\Omega’ = \Omega \cup d$ is the set of nodes s may meet after t=0 and $\mu<em>d = \frac{1}{\lambda</em>{s, d}}$, $\mu<em>i = \frac{1}{\lambda</em>{s, d}+\lambda<em>{i, d}}$<br>It is clear that $E(T</em>{s, d})$ is simply a weighted sum over $\mu<em>i$. To get the minimum $E(T</em>{s, d})$ over all possible $\Omega$, we can use a simple algorithm as follows:</p>
<ol>
<li>sort $\mu_i$ in ascending order</li>
<li>add $N<em>i$ to $\Omega‘$ if it decreases $E(T</em>{s, d})$</li>
</ol>
<p><strong>Note: </strong>initially destination d has to be in the set.</p>
<p>The average delivery delay of multi-copy-multi-hop routing scheme:<br>$E(T<em>{s, d}^n) = \frac{1}{\lambda</em>{s, d}+\sum_{i \in \Omega<em>n}\lambda</em>{s, i} }+ \sum_{i \in \Omega<em>n}\frac{\lambda</em>{s, i}}{\lambda<em>{s, d}+\sum</em>{i \in \Omega<em>n}\lambda</em>{s, i}}E(min{T<em>{s, d}^{n-1}, T</em>{i, d}^{n-1}})$</p>
<p>The upper bound for $E(min{T<em>{s, d}^{n-1}, T</em>{i, d}^{n-1}})$ is ${E(T<em>{s, d}^{n-1}), E(T</em>{i, d}^{n-1})}$<br>To derive the forwarding sets for each state, we start from state 1 of s, which involves only its direct neighbors $N_1, \cdots, N_m$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/Multi-hop-vs-Two-hop-Routing-Modeling-Simulation-in-DTN/" data-id="cimvy2ecs0004c4xtqe1x8t3o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spray-and-Wait" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/Spray-and-Wait/" class="article-date">
  <time datetime="2016-03-28T22:18:28.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/Spray-and-Wait/">Spray and Wait</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="An-Efficient-Routing-Scheme-for-Intermittently-Connected-Mobile-Networks"><a href="#An-Efficient-Routing-Scheme-for-Intermittently-Connected-Mobile-Networks" class="headerlink" title="An Efficient Routing Scheme for Intermittently Connected Mobile Networks"></a><a href="#An_Efficient_Routing_Scheme_for_Intermittently_Connected_Mobile_Networks" title="An Efficient Routing Scheme for Intermittently Connected Mobile Networks"></a>An Efficient Routing Scheme for Intermittently Connected Mobile Networks</h1><h2 id="General-spray-and-wait"><a href="#General-spray-and-wait" class="headerlink" title="General spray and wait:"></a><a href="#General_spray_and_wait_3A" title="General spray and wait:"></a>General spray and wait:</h2><p>Definition: <em>Spray and Wait routing consists of the following two phases:</em></p>
<ol>
<li>Spray phase: for every message originating at a source node, L message copies are initially spread - forwarded by the source and possibly other nodes receiving a copy - to L distinct “relays”.</li>
<li>Wait phase: if the destination is not found in the spraying phase, each of the L nodes carrying a message copy performs direct transmission.</li>
</ol>
<h2 id="Binary-spray-and-wait"><a href="#Binary-spray-and-wait" class="headerlink" title="Binary spray and wait:"></a><a href="#Binary_spray_and_wait_3A" title="Binary spray and wait:"></a>Binary spray and wait:</h2><p>The source of a message initially starts with L copies; any node A that has n &gt; 1 message copies (source or relay), and encounters another node B (with copies), hands over to B[n/2] and keeps [n/2] for itself; when it is left with only one copy, it switches to direct transmission.</p>
<p>Binary Spray and Wait is optimal under IID condition (Independently and Identically Distributed).</p>
<p>Theorem: When all nodes move in an IID manner, Binary Spray and Wait routing has the minimum expected delay among all spray and wait routing algorithms.</p>
<h2 id="Optimization-to-meet-performance-constraints"><a href="#Optimization-to-meet-performance-constraints" class="headerlink" title="Optimization to meet performance constraints"></a><a href="#Optimization_to_meet_performance_constraints" title="Optimization to meet performance constraints"></a>Optimization to meet performance constraints</h2><p>Question: what does ICMN network stand for?<br>Lemma 1: Let M nodes with transmission range K perform independent random walks on a $\sqrt{N}*\sqrt{N}$ torus. Then:</p>
<ol>
<li>The delay of Direct Transmission is exponentially distributed with the average<br>$ED_{dt} = 0.5N(0.34logN - \frac{2^{K+1}-K-2}{2^K -1})$</li>
<li>The expected delay of the optimal algorithm is:<br>$ED<em>{opt} = \frac{H</em>{M-1}}{M-1}ED_{dt}$<br>_where $H_n$ is the $n^{th}$ Harmonic Number, i.e, $H<em>n = \sum</em>{i=1}^{n}\frac{1}{i} = \Theta(logn)$_</li>
</ol>
<p>Lemma2:<br><em>The expected delay of Spray and Wait, when L message copies are used, is upper-bounded by</em><br>$ED<em>{sw} \leq (H</em>{M-1} - H<em>{M-L})ED</em>{dt} + \frac{M-L}{M-1}\frac{ED_{dt}}{L}$<br><em>The bound is tight when $L \ll M$</em></p>
<h2 id="Choose-L-to-Achieve-a-Required-Expected-Delay"><a href="#Choose-L-to-Achieve-a-Required-Expected-Delay" class="headerlink" title="Choose L to Achieve a Required Expected Delay"></a><a href="#Choose_L_to_Achieve_a_Required_Expected_Delay" title="Choose L to Achieve a Required Expected Delay"></a>Choose L to Achieve a Required Expected Delay</h2><p>Lemma 3: The minimum number of copies $L<em>{min}$ needed for Spray and Wait to achieve an expected delay at most $aED</em>{opt}$ is independent of the size of the network N and transmission range K, and only depends on a and the number of nodes M.</p>
<p>Estimate for $L<em>{min}$:<br>$(H</em>{M}^{3} - 1.2)L^3 + (H<em>{M}^{2} - \frac{\pi^2}{6})L^2 + (a + \frac{2M-1}{M(M-1)})L = \frac{M}{M-1}$ where $H</em>{r}^{n} = \sum_{i=1}^{n}\frac{1}{i^r}$ is the $n^{th}$ Harmonic number of order r.</p>
<h3 id="Estimate-for-M-number-of-nodes"><a href="#Estimate-for-M-number-of-nodes" class="headerlink" title="Estimate for M (number of nodes)"></a><a href="#Estimate_for_M__28number_of_nodes_29" title="Estimate for M (number of nodes)"></a>Estimate for M (number of nodes)</h3><p>let $T_1$ be the time until a node encounters any other node<br>from Lemma 2, T1 is exponentially distributed with average $T<em>1 = \frac{ED</em>{dt}}{M-1}$<br>let $T_2$ be the time until two different nodes are encountered, then the expected value of $T<em>2$ equals $ED</em>{dt}(\frac{1}{M-1} + \frac{1}{M-2})$.<br>Then it is easy to get estimate M:<br>$\hat{M} = \frac{2T_2 - 3T_1}{T_2 - 2T_1}$</p>
<p>$\hat{T<em>1} = \frac{1}{n}\sum</em>{k=1}^{n}(\frac{M-c<em>k}{M-1})T</em>{1,k}$<br>$\hat{T<em>2} = \frac{1}{n}\sum</em>{k=1}^{n}[(\frac{M-c<em>{k-1}}{M-1})T</em>{1,k-1} + (\frac{M-c<em>k}{M-2})T</em>{1,k}]$<br>then replacing the $T_1$ and $T_2$ in the equation for $\hat{M}$, we get a current estimate of M.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/Spray-and-Wait/" data-id="cimvy2edl000jc4xtibk8wkc9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BUBBLE-Rap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/BUBBLE-Rap/" class="article-date">
  <time datetime="2016-03-28T22:18:23.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/BUBBLE-Rap/">BUBBLE Rap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Social-based-Forwarding-in-Delay-Tolerant-Networks"><a href="#Social-based-Forwarding-in-Delay-Tolerant-Networks" class="headerlink" title="Social-based Forwarding in Delay Tolerant Networks"></a><a href="#Social-based_Forwarding_in_Delay_Tolerant_Networks" title="Social-based Forwarding in Delay Tolerant Networks"></a>Social-based Forwarding in Delay Tolerant Networks</h1><p>Improved understanding of human mobility in terms of social structures, and to use these structures in the design of forwarding algorithms for Pocket Switched Networks(PSNs).</p>
<p>For PSN, mobility is often unpredictable, and topology changes can be rapid, many MANET and some DTN routing algorithms forwarding by building and updating routing tables whenever mobility occurs might not be efficient.</p>
<p> A PSN is formed by people, and social relationships may vary much more slowly than the topology.</p>
<p>Two aspects: community and centrality.</p>
<p><em>Community</em>: Cooperation and division.<br><em>Centrality</em>: Within a community, some people are more popular and interact with more people than others. They are called “hubs”.</p>
<p><strong>To-do</strong>: Freeman [8] has defined several centrality metrics to measure the importance of a node in a network. </p>
<h2 id="Bubble-Rap-Forwarding"><a href="#Bubble-Rap-Forwarding" class="headerlink" title="Bubble Rap Forwarding"></a><a href="#Bubble_Rap_Forwarding" title="Bubble Rap Forwarding"></a>Bubble Rap Forwarding</h2><p>Two intuitions:</p>
<ol>
<li>People have varying roles and popularities in society</li>
<li>People form communities in their social lives</li>
</ol>
<p>Two assumptions:</p>
<ol>
<li>Each node belongs to at least one community. Single node communities are allowed.</li>
<li>Each node has a global ranking (i.e. global centrality) across the whole system, and also a local ranking within its local community. It may also belong to multiple communities and hence may have multiple local rankings.</li>
</ol>
<p>Forwarding:<br>If a node has a message destined for another node, this node first bubbles the message up the hierarchical ranking tree using the global ranking, until it reaches a node which is in the same community as the destination node. Then the local ranking system is used instead of the global ranking, and the message continues to bubble up through the local ranking tree until the destination is reached or the message expires.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin:&#10;&#9;foreach EncounteredNode_i:&#10;&#9;&#9;if(LabelOf(currentNode) == LabelOf(destination)):&#10;&#9;&#9;&#9;if(&#10;&#9;&#9;&#9;LabelOf(EncounteredNode_i) == LabelOf(destination)&#10;&#9;&#9;&#9;&#38;&#38;&#10;&#9;&#9;&#9;LocalRankOf(EncounteredNode_i &#62; localRankOf(currentNode))&#10;&#9;&#9;&#9;):&#10;&#9;&#9;&#9;EncounteredNode_i.addMessageToBuffer(message)&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;if(&#10;&#9;&#9;LabelOf(EncounteredNode_i) == LabelOf(destination)&#10;&#9;&#9;||&#10;&#9;&#9;GlobalRankOf(EncounteredNode_i &#62; GlobalRankOf(currentNode)&#10;&#9;&#9;&#9;):&#10;&#9;&#9;&#9;&#9;EncounteredNode_i.addMessageToBuffer(message)&#10;end</span><br></pre></td></tr></table></figure>

<p><strong>To-do</strong>: To calculate the individual centrality value for each node, we first carry out a large number of emulations of unlimited flooding with different uniformly distributed traffic patterns created using the <em>HaggleSim</em> emulator [11]</p>
<p>Community Detection:<br>K-CLIQUE:<br>Definition: a k-clique community is a union of all complete subgraphs of size k that can be reached from each otehr through a series of adjacent k-cliques, where two k-cliques are said to be adjacent if they share k-1 nodes.<br>WNA (Weighted Network Analysis):<br>For each community partitioning of a network, the corresponding modularity value $Q = \sum<em>{vw}[\frac{A</em>{vw}}{2m} - \frac{k_v k_w}{(2m)^2}]\delta(c_v, c<em>w)$<br>$A</em>{vw}$ is the value of the weight of the edge between vertices v and w, if such an edge exists and 0 otherwise;<br>$\delta(i, j)$ is 1 if $i == j$ and 0 otherwise;<br>$m = \frac{1}{2}\sum<em>{vw}A</em>{vw}$;<br>$k_v$ is the degree of vertex v defined as $\sum<em>w A</em>{vw}$ and $c_i$ denotes the community of which vertex i belongs to.</p>
<p>Modularity: the strength of division of a network into modules. High Modularity -&gt; dense connections -&gt; less connections between communities</p>
<p>Rank calculating:<br>RANK: using only centrality information<br>DEGREE: degree per unit-time slot<br>S-Window: the degree for previous unit-time slot such that when two nodes meet each other, they compare how many unique nodes they have met in the previous unit-time slot. (during encounter)<br>C-Window: calculate the average degree for every unit-time slot. (during encounter)</p>
<p>Questions:</p>
<ol>
<li>How does WNA work.2.  relationships between centrality and different rank calculating algorithms</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/BUBBLE-Rap/" data-id="cimvy2ecq0003c4xtjhvgg5cu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Introduction-to-MANET" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/Introduction-to-MANET/" class="article-date">
  <time datetime="2016-03-28T22:18:12.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/Introduction-to-MANET/">Introduction to MANET</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>transmission range:<br>the range in which a transmitter can pass its information for its best</p>
<p>three kinds of networks:</p>
<ol>
<li>Almost connected networks:<br>— Relatively dense, exhibits partitions. Good percentage of pairs are connected end-to-end at any time. Traditional protocols could still diliver a part of the traffic, but unable to deliver any traffic between nodes that lie in different partitions. Opportunistic forwarding complementing path-based protocols.</li>
<li>Sparse networks<br>— No large clusters exist. Nodes are isolated most of the time. Two nodes come into contact for a limited contact duration. A message must be routed predominantly by opportunistic forwarding. When a new candidate is encountered, the forwarding scheme must decide whether it should handover the message, forward a copy or do nothing. Available bandwidth per contact and/or node buffer space are the limiting factors as far as performance is concerned. Forwarding or scheduling techniques that aim to choose the right neighbor or combine packets for different neighbors will not offer much here.</li>
<li>Clusters or Connectivity Islands<br>— Exhibits significant clustering and community structure, with well defined islands of (good) connectivity, and few or no contemporary oaths between clusters.</li>
</ol>
<p>Mobility:<br>It defines how a sequence of connectivity graph snapshots may look like, how the properties of subsequent snapshots depend on the current one.<br>Responsible for the amount of variability between different realizations of the network over time, but also for the ability to predict how the experienced realization will evolve and result in future contacts.</p>
<p>Mobility Intensity:<br>The magnitude of the surface area it traverses in a given amount of time. The larger this area, the more the contact( and thus forwarding opportunities this node will have), and, the shorter duration of these occuring contacts as well.<br>Related to the absolute speed of the node and the frequency and duration of pauses.</p>
<p>Mobility Locality:<br>Relates the mobility of a node to the total network area. A given node may move within only a small subset of locations and never or infrequently visit the rest of the network.<br>Recent models attempt to reproduce this behavior by assigning “home locations” to each node.<br>Mark: Markov chain</p>
<p>Mobility Regularity:<br>The expectation of periodicity and pattern.</p>
<p>Mobility Heterogeneity:<br>Nodes may exhibit significant diferences with other nodes’ patterns.</p>
<p>Mobility Correlations:<br>While not all nodes in a given mobility scenario are expected to exhibit uniform mobility characteristics, subsets of nodes will be subject to higher correlations in their preferred locations and visiting patterns.</p>
<p>Node Resources:<br>Bandwidth<br>Storage<br>Battery Lifetime<br>Heterogeneous Node Capabilities(*)</p>
<h3 id="11-3-Dealing-with-uncertainty"><a href="#11-3-Dealing-with-uncertainty" class="headerlink" title="11.3 Dealing with uncertainty"></a><a href="#11-3_Dealing_with_uncertainty" title="11.3 Dealing with uncertainty"></a>11.3 Dealing with uncertainty</h3><p><strong>Model 1: Epidemic Routing</strong><br>Each node maintains a message vector indicating which messages the current node is storing in its buffer. When two nodes encounter, they first exchange and compare their message vectors. Then they exchange all messages not in common, so that, at the end of the contact, both nodes are storing exactly the same messages.<br>Positive: guaranteed to find the shortest space-time path<br>Negative: </p>
<ol>
<li>immense overhead per message. In a network of N nodes, the overhead of epidemic routing grows to infinity as $\frac{N}{\log N}$ unless some special measures are taken.</li>
<li>If node buffer space and contact bandwidth are limited, epidemic routing is no longer optimal. Depending on the buffer management and scheduling policies, new messages may kick out old messages before the latter are delivered, leading to congestion collapse phenomena.</li>
</ol>
<p>Revision 1: IMMUNE_TX and VACCINE recovery schemes:<br>After a destination receives a message, it propagates “anti-messages” to infected nodes and, respectively to all nodes. Since anti-messages have much smaller sizes(only message ID), the overhead is effectively reduced.</p>
<p>Revision 2: Gossiping or Randomized Flooding:<br>Copy a message during a contact with a probability $p$ less than 1.<br>OR<br>ASllow each relay to copy the message to at most $k$ other nodes.<br>Requires a priori knowledge of global network parameters. In practice, all these schemes result in almost every node receiving a copy of each message.</p>
<p>Revision 3: Limited-time Flooding:<br>Set a threshold on the epidemic routing time. Before the threshold timer expires, messages are spread using epidemic routing. When the timer expires, any node with the message may only transmit it directly to the destination.<br>Carefully selection of the timer is needed.<br>Very useful for analytical purposes.</p>
<p>Revision 4: 2-hop scheme:<br>Allow only the source of a message to create and forward replicas.<br>In an uniform mobility environment, this scheme results in an average number of $\frac{N-1}{2}$ transmission per message. Yet only paths of at most 2 hops can be used, only for very local mobility scenarios.</p>
<p>SLEF(Self-Limiting Epidemic Forwarding):<br>Reduce the number of hops each message is allowed to traverse, as a function of the perceived congestion.<br>An online mechanism to infer local congestion is necessary for SLEF to operate.<br>A sensible solution for applications like the broadcasting of location-related content, not suitable for generic, end-to-end unicast or multicast.</p>
<p><strong>Model 2: Controlled Replication Schemes</strong><br>Often referred to as <em>Spray and Wait</em><br>Ensure that each message is delivered with at most L transmissions, where $L\ll N$. Different flavors of spraying achieve this goal with different policies during the first “spraying” phase:</p>
<ol>
<li>Source Spraying: The source os a message alone may create additional copies and forward them to encountered relays.<br>Difference to 2-hop scheme: the source stops after having distributed $L-1$ copies or sooner, if the destination was among the first L-1 nodes encountered. Then, the source and the relays may only forward the message to the destination, which is the “wait” phase.</li>
<li>Binary Spraying: To speed up the spraying phase, relays can be also allowed to spread copies further. To ensure that the total number of copies remains $\leq$ L, a quota system is implemented.<blockquote>
<p>(i)the source starts with one message copy and a quota of L allowed replications<br>(ii)when a node with a message copy and a quota $i&gt;1$ encounters a relay without a copy, it forwards a message copy and half of the quota. Then they both have quota of $[i/2]$<br>(iii)a node with a copy and a quota of 1 may only forward the message to the destination</p>
</blockquote>
</li>
</ol>
<p>Notes:</p>
<ol>
<li>Under IID(independent and identically distributed) mobility, binary spraying has the shortest delay among all quota0based spraying methods.</li>
<li>Source spraying may be preferred in some scenarios where only the source can be <em>relied on</em> to spread copies.</li>
<li>If the mobility model is characterized by high mobility intensity and low locality, Spray and Wait can achieve similar delays to epidemic routing with almost an order of magnitude fewer transmissions.</li>
<li>The performance increase, when using more and more replicas, obeys a <em>law of diminishing returns</em></li>
<li>One can analytically solve for the number of copies to achieve a desired performance compared to the optimal (epidemic under no resource constraints) — independent of the actual mobility model and independent of the size of the geographic area in which network nodes are moving.</li>
<li>Performance of controlled replication algorithms can drop rapidly when nodes show strong location preference, correlated mobility, etc.</li>
</ol>
<h3 id="11-4-Capitalizing-on-structure-Utility-based-forwarding"><a href="#11-4-Capitalizing-on-structure-Utility-based-forwarding" class="headerlink" title="11.4 Capitalizing on structure: Utility-based forwarding"></a><a href="#11-4_Capitalizing_on_structure_3A_Utility-based_forwarding" title="11.4 Capitalizing on structure: Utility-based forwarding"></a>11.4 Capitalizing on structure: Utility-based forwarding</h3><p> A number of sophisticated opportunistic forwarding schemes are based on the following basic functions:</p>
<ol>
<li>Collect and analyze some statistics about past contacts among (all or a subset of) nodes;</li>
<li>Assign a utility for each node based on these statistics; this utility may be <em>destination-dependent</em> or <em>destination-independent</em> and aims at quantifying the ability of a candidate next hop to deliver the message probablistically closer to a destination.</li>
<li>Perform a deterministic or probabilistic decision as a function of the current relay’s and the candidate relay’s utilities (and perhaps additional parameters).</li>
</ol>
<p>Utility-based single-copy algorithms<br>When the node currently holding the message encounters another node with a higher utility than the current one, the message is handed over and no local copy is retained. (Exception: the source node)</p>
<p>Contact-based Utility:<br>Mobility: key role as both an enabler and differentiator between nodes’ future contact probabilities. </p>
<p><strong>Model 1: Pair-based Contact Utilities</strong><br>individual node pair: an intended destination and a node being evaluated as candidate relay for that destination.<br>Properties:</p>
<ol>
<li>Age of Last Encounter: the time elapsed since two nodes last encountered each other.<br>In DTNs, when nodes are heterogeneous in terms of their characteristics and capabilities, additional parameters should be used in combination with the age of last encounter.<br>If node mobility is relatively uniform, the age of last encounter only offers benefits in denser connectivity environments</li>
<li>History of Past Encounters: keep track of a longer history of past contact and their statistics.<br>Derive different utilities: frequency &amp; contact duration</li>
<li>More Complex Pair Contact Predictors</li>
<li>Pattern of Visited Location: People tend to follow a <em>movement pattern</em> in their daily activities. <em>Location preference</em> as well as the periodic nature of human mobility have been consistently demonstrated in a variety of real mobility traces.<br>Mobility patterns could help identify a <em>profile</em> for a given node; nodes with a mobility profile matching or similar to the destination can be considered good candidate relays for messages to that destination.</li>
</ol>
<p>Maintenance and Overhead of Contact Statistics: Exponentially Weighted time Averages(EWMA) are more often used.</p>
<p><strong>Model 2: Contact Graph Utilities</strong><br>pairwise contact metrics might fail in cases, for example, when X rarely meets D, but X meets Y often and Y meets D often. Or, X meets many nodes in general and thus increasing the chances to meet D.</p>
<p>Complex networks and social networks<br>Key steps:</p>
<ol>
<li>Create the contact graph out of a sequence of past (instantaneous) connectivity graphs</li>
<li>Use contact graph properties to compose a utility function that efficiently identifies “good” next hops.</li>
</ol>
<p>A sequence of binary matrices <strong>A(t)</strong> corresponds to the connectivity as each time instant t.</p>
<ol>
<li>Weighted graph: A scalar weight $w<em>{ij}$ is derived as a function of the **$A(t)</em>{ij}$** for some past time window(eg, $[t_1, t<em>2]$).$w</em>{ij} = f(A(t<em>{1})</em>{ij}, A(t<em>{1}+1)</em>{ij}, …, A(t<em>{2})</em>{ij})$</li>
<li>Unweighted graph: if the contact graph is unweighted, then a link may either exist or not exist. This could be achieved for example by introducing a cutoff threshold for weights: if the link weight $w_{ij}$ is below this value, then it is removed from the contact graph.</li>
</ol>
<p>Some key properties that seem to underlie many mobility scenarios for contact graphs:</p>
<ol>
<li>Community structure: Contact graphs seem to exhibit considerable community structure with subsets of nodes well-connected to each other, with fewer or weaker links between subsets.</li>
<li>Small world: Contact graphs exhibit small world properties, namely very short paths between any two nodes usually exist. However, it does not imply that these paths can be easily found.</li>
<li>Skewed degree distribution: Contact graph weight distributions and node degree distributions exhibit considerable heterogeneity.</li>
</ol>
<p>Centrality-based Utility:<br>The <em>betweeness centrality</em> of a node $i$ is defined as the number of shortest paths between any network nodes going through node $i$.  Nodes with high betweeness centrality can serve as “bridges” between communities relaying the message from the community the source lies in to the community the destination lies in.<br>Cannot be easily calculated since it requires global network information</p>
<p>The <em>degree centrality</em> is the degree of the node in the contact graph (or the sum of link weights, in the weighted case).<br>Essentially related to the amount of mobility of a given node and the total rate of meetings of that node with all other network nodes.</p>
<p>The <em>Similarity-based Utility</em> is the similarity between two nodes. Two nodes are <em>similar</em> if they have a lot of common neighbors in the contact graph. </p>
<p><em>Complete Social Network Analysis-based Schemes</em><br>SimBet uses a per node utility that takes into account both the similarity of a given relay $i$ with the intended destination $d$ (denoted as $Sim_i(d)$ here), as well as the ego-centrality of the same relay, $Bet_i$<br>$U_i(d) = \alpha Sim_i(d) + \beta Bet_i$</p>
<p><em>Probabilistic Path-based Utilities</em><br>node $i$ may be a good next hop because it is in the beginning of a space-time path that has a high chance of realization.</p>
<p><strong>Non-contact-based Utility</strong><br>Forward or replicate a message to a relay based upon the available resources in order to maximize the likelihood of message delivery, when two nodes meet. In some examples, utilities are defined based on the total buffer occupancy permessage. Messages then are ordered with respect to their utilities, keeping in view the goal of optimizing specific quantities, which allows computation of desired performance metrics such as worst-case delivery delay and packet delivery ratio. </p>
<p><em>Social Relations</em><br>People who are socially-related to each other are expected to interact more often with each other.</p>
<h3 id="11-5-Hybrid-solutions-Combining-Redundancy-and-Utility"><a href="#11-5-Hybrid-solutions-Combining-Redundancy-and-Utility" class="headerlink" title="11.5 Hybrid solutions: Combining Redundancy and Utility"></a><a href="#11-5_Hybrid_solutions_3A_Combining_Redundancy_and_Utility" title="11.5 Hybrid solutions: Combining Redundancy and Utility"></a>11.5 Hybrid solutions: Combining Redundancy and Utility</h3><p><strong>Utility-based Flooding</strong><br>Pass the value to another node if it satisfies the utility criterion:</p>
<ol>
<li>Absolute utility criterion: $U<em>j(d) &gt; U</em>{thresh}$</li>
<li>Relative utility criterion: $U_j(d) &gt; U<em>i(d) + U</em>{thresh}$</li>
</ol>
<p>Eg. PRoPHET is a utility-based flooding scheme, and it has the following properties:</p>
<ol>
<li>it increases when i meets d</li>
<li>it decreases with time, when i is not in contact with d</li>
<li>it increases when i meets another node j, with a non-zero utility for d</li>
</ol>
<p><strong>Spray and Utility-based Spraying</strong><br>A source could spray the limited budget of copies quickly after message creation, and then allow each copy to be further forwarded(hand over, not copied) using an appropriate utility-based scheme.<br><em>Spray and Focus</em> performs binary spraying of L copies, as in the <em>Spray and Wait</em> case. However, after the replication quota for a relay node reaches 1, it can still hand over its copy to another, better relay, if it encounters one. The utility is a simple pairwise contact utility, similar to the one in PRoPHET.</p>
<p><strong>Smart Replication</strong><br>Use explicit “labels” or a degree centrality estimate as the utility. Then, binary or source spraying is employed, with copies forwarded only to relays that either have a higher utility or have a high enough utility.</p>
<p>Memoryless</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/Introduction-to-MANET/" data-id="cimvy2ecw0008c4xta5f3ll9g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-随建即连网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/随建即连网络/" class="article-date">
  <time datetime="2016-03-28T22:18:07.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/28/随建即连网络/">随建即连网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定义与名词解释"><a href="#定义与名词解释" class="headerlink" title="定义与名词解释"></a><a href="#u5B9A_u4E49_u4E0E_u540D_u8BCD_u89E3_u91CA" title="定义与名词解释"></a>定义与名词解释</h2><blockquote>
<p>随建即连网络（Mobile Ad-Hoc Network, abbr. MANET）是无线随意网络（Wireless Ad-Hoc Network, abbr. WANET）的一种。它是一种以移动设备，通过无线链接，自我配置所形成的网络。在MANET之中的每个移动设备都可以自由移动，随时改变无线链接。每个移动设备节点都必须协助转发网络数据包，即使这个数据包是跟这个设备无关的。要创建一个 MANET，最根本的挑战在于让每个移动设备都能够得到足够的信息，以协助保持网络信息的流通。<br>–引自<a href="https://zh.wikipedia.org/wiki/隨建即連網路">维基百科</a></p>
</blockquote>
<p>网络可以分为以下几种：</p>
<ol>
<li>Almost Connected Networks：顾名思义，相对连接比较密集的网络。大部分的pair都是相连的。传统传输协议仍然是主要的传输方法，但是因为网络中存在partition，需要用opportunistic forwarding来补充传统的path-based协议。</li>
<li>Sparse Networks：不存在大规模cluster，节点在大部分时间都是相互隔绝的，偶尔两节点相遇时进行信息传递，完全依赖于opportunistic forwarding。</li>
<li>Clusters or Connectivity Islands：呈现以不同cluster组成的结构，cluster内部连接紧密，不同cluster之间连接稀疏。</li>
</ol>
<p>网络有以下性质：<br>Mobility：基于某时刻网络的“快照”，网络的性质会如何变化。<br>Mobility Intensity：一定时间内信息传播的面积大小，面积越大，该节点相遇的节点更多，相遇时间越短。<br>Mobility Locality：一个节点可能会局限于一部分区域移动而很少光顾其他区域。<br>Mobility Regularity：出现周期性行为的期望。<br>Mobility Heterogeneity：每个节点的模式都非常不同。<br>Mobility Correlations：一部分节点呈现出相似的活动模式与地点，较高的关联度。</p>
<h2 id="几种常见的opportunistic-forwarding策略"><a href="#几种常见的opportunistic-forwarding策略" class="headerlink" title="几种常见的opportunistic forwarding策略"></a><a href="#u51E0_u79CD_u5E38_u89C1_u7684opportunistic_forwarding_u7B56_u7565" title="几种常见的opportunistic forwarding策略"></a>几种常见的opportunistic forwarding策略</h2><h3 id="策略一：Epidemic-Routing及其优化版本"><a href="#策略一：Epidemic-Routing及其优化版本" class="headerlink" title="策略一：Epidemic Routing及其优化版本"></a><a href="#u7B56_u7565_u4E00_uFF1AEpidemic_Routing_u53CA_u5176_u4F18_u5316_u7248_u672C" title="策略一：Epidemic Routing及其优化版本"></a>策略一：Epidemic Routing及其优化版本</h3><p>Epidemic Routing 基本策略：<br>每个节点储存其消息向量（message vector）来记录当下它记录了哪些信息。当两个节点相遇时，先比较两者的消息向量，然后交换非公共的消息内容。每次相遇完成后，两个节点都将持有完全相同的消息。<br>优点：能够保证找到最短的时空传输路径。<br>缺点：<br>    冗余（overhead，不知道怎么翻译）过高。epidemic routing的overhead可以以$\frac{N}{log_N}$增长至无限。<br>    如果节点的储存空间有限，epidemic routing不太现实。当储存空间不足时，新信息会将老信息在其传达完毕前踢出，导致congestion collapse。</p>
<p>改版一：IMMUNE_TX and VACCINE recovery schemes<br>在目标收到信息后，发出一个“抵消信息”来进行传播，然后消去网络中所有该信息的副本。因为抵消信息只需要储存信息的ID，其大小会小很多，因此可以很有效地减少overhead。</p>
<p>改版二：Gossiping or Randomized Flooding<br>在相遇时，以概率p来进行消息拷贝<br>或者<br>允许每个节点对该消息发放k份拷贝</p>
<p>改版三：Limited-time Flooding<br>设置一个epidemic routing时间门槛。在时间消耗完之前，先进行epidemic routing。之后停止所有拷贝，每个节点都只有在遇到目的地时才进行传递。</p>
<p>改版四：2-hop scheme<br>只有消息的源头可以创建拷贝，其余拷贝只有在遇到目的地时才传递消息。消息从起点到终点只进行两次跳跃（2-hop）。平均下来，该方法每个消息传递\frac{N-1}{2}次。</p>
<p>改版五：SLEF(Self-Limiting Epidemic Forwarding)<br> 随着congestion的升高，减少每个消息允许的跳跃次数(number of hops)。需要一个事实检测congestion的机制。</p>
<h3 id="策略二：Controlled-Replication-Schemes-Spray-and-Wait"><a href="#策略二：Controlled-Replication-Schemes-Spray-and-Wait" class="headerlink" title="策略二：Controlled Replication Schemes(Spray and Wait)"></a><a href="#u7B56_u7565_u4E8C_uFF1AControlled_Replication_Schemes_28Spray_and_Wait_29" title="策略二：Controlled Replication Schemes(Spray and Wait)"></a>策略二：Controlled Replication Schemes(Spray and Wait)</h3><p>Spray and Wait基本策略：<br>确保每条消息只被复制最多L次，不同的模型用不同的方法来达到这个效果。在Spray阶段，一般有如下两种传递方法：</p>
<ol>
<li>Source Spraying：只有消息的源头可以进行消息的复制传递，在进行L－1次复制之后，不再创建新的备份，只有在遇到目的地时才进行消息传递。</li>
<li>Binary Spraying：每一个节点在遇到一个不存有该消息的节点时，将自己拷贝数量的一半传递给对方，然后让对方以同样的方式进行传递。当拷贝数量为1时，除非遇到目的地，停止传递。</li>
</ol>
<p>注意：</p>
<ol>
<li>通常情况下Binary Spraying是更佳策略。Source Spraying一般用于消息依赖于源头的情况下。</li>
<li>如果网络有高mobility intensity和低的locality，Spray and Wait能达到和epidemic一样的传递时间而低至少一个数量级的传递数。</li>
<li>拷贝数上限L往往是可求解的。</li>
<li>高locality网络中，该策略的效率急剧降低。</li>
</ol>
<h3 id="策略三：Utility-based-forwarding"><a href="#策略三：Utility-based-forwarding" class="headerlink" title="策略三：Utility-based forwarding"></a><a href="#u7B56_u7565_u4E09_uFF1AUtility-based_forwarding" title="策略三：Utility-based forwarding"></a>策略三：Utility-based forwarding</h3><p>该模型基于以下几个思路：</p>
<ol>
<li>搜集并分析之前的相遇数据。</li>
<li>给每一个节点计算一个utility值，来表示该节点作为使消息离终点更近的传递者的能力。</li>
<li>在进行传递时，依据节点的utility采取不同的行为。</li>
</ol>
<p>模式一：Utility-based single-copy algorithms<br>当一个节点遇到一个比自己utility高的节点时，将消息传递出去，自己不留备份。</p>
<p>模式二：Contact-based Utility<br>Mobility是区分一个节点遇到之后节点的关键。</p>
<h4 id="模型一：Pair-based-Contact-Utilities"><a href="#模型一：Pair-based-Contact-Utilities" class="headerlink" title="模型一：Pair-based Contact Utilities"></a><a href="#u6A21_u578B_u4E00_uFF1APair-based_Contact_Utilities" title="模型一：Pair-based Contact Utilities"></a>模型一：Pair-based Contact Utilities</h4><p>以一个节点对作为单位，计算该两个节点相遇的Utility<br>考虑以下信息：</p>
<ol>
<li>距离上次相遇的时间</li>
<li>过去的相遇节点</li>
<li>一些其他的预测信息</li>
<li>该节点的活动规律</li>
</ol>
<h4 id="模型二：Contact-Graph-Utilities"><a href="#模型二：Contact-Graph-Utilities" class="headerlink" title="模型二：Contact Graph Utilities"></a><a href="#u6A21_u578B_u4E8C_uFF1AContact_Graph_Utilities" title="模型二：Contact Graph Utilities"></a>模型二：Contact Graph Utilities</h4><p>关键步骤：</p>
<ol>
<li>根据过去的节点的连接图来创建联络图</li>
<li>根据联络图来推断utility</li>
</ol>
<p>用一个二维数组 <strong>A(t)</strong>来存储在时刻t联络图的连接状态</p>
<ol>
<li>有权图：用一个标量函数来表示对于某时间段$[t_1, t<em>2]$点i与j之间的连接状态<br>$w</em>{ij} = f(A(t<em>{1})</em>{ij}, A(t<em>{1}+1)</em>{ij}, …, A(t<em>{2})</em>{ij})$</li>
<li>无权图：一方面，图中可以只存储连接的连与断（0或1）；另一方面，可以给$w_{ij}$设一个阀值，超过即为真。</li>
</ol>
<p>对于contact graph，有一些性质很关键：</p>
<ol>
<li>Community Structure</li>
<li>Small World：通常两个点之间存在十分短的路径，但是这并不代表这条路径能被很容易地找到。</li>
<li>Skewed degree distribution：有很强的heterogeneity。</li>
</ol>
<p>对于utility的计算，一般有以下几种：</p>
<ol>
<li>Centrality-based Utilities：<br>betweeness centrality被定义为穿过节点i的最短路径数量。但是此定义下的centrality难以计算，因为需要网络全局的数据。此外有计算简便的degree centrality，即该节点连接的节点数目。</li>
<li>The Similarity-based Utility：</li>
<li>Complete Social Network Analysis-based Schemes:<br>同时考虑了similarity（$Sim_i(d)$）和ego－centrality（$Bet_i$）<br>$U_i(d) = \alpha Sim_i(d) + \beta Bet_i$</li>
<li>Probabilistic Path-based Utilities<br>某个点适合做跳跃点，因为它在一条高实现概率的通路的起点。</li>
</ol>
<h3 id="策略四：混合Redundancy和Utility"><a href="#策略四：混合Redundancy和Utility" class="headerlink" title="策略四：混合Redundancy和Utility"></a><a href="#u7B56_u7565_u56DB_uFF1A_u6DF7_u5408Redundancy_u548CUtility" title="策略四：混合Redundancy和Utility"></a>策略四：混合Redundancy和Utility</h3><p>除了以上提到的几种基本策略，许多人也会想到将上述策略进行混合，取长补短，来达到更高效率。</p>
<p>举例一：Utility-based Flooding<br>只在相遇的节点达到一定Utility时才进行传递，又分为两种情况：</p>
<ol>
<li>绝对Utility门槛：$U<em>j(d) &gt; U</em>{thresh}$</li>
<li>相对Utility门槛：$U_j(d) &gt; U<em>i(d) + U</em>{thresh}$</li>
</ol>
<p>PRoPHET即是使用了Utility－based Flooding，它遵循下述规则：</p>
<ol>
<li>当某节点遇到目的地时，Utility增加。</li>
<li>未与目的地相遇时，Utility随时间减少。</li>
<li>当遇到另一个Utility不为零的节点时，Utility增加</li>
</ol>
<p>举例二：Spray and Utility-based Spraying<br>Spray的初期阶段时，先快速发放，然后再Wait阶段不进行wait，而是每次遇到utility比自己高的节点都将信息传递出去（自己不留拷贝）。<br><em>Spray and Focus</em>是其中一种重要的实现，该方法先进行binary spray，然后每当遇到比自己Utility高的节点都将消息传递出去。utility通过类似于PRoPHET的方式进行计算。</p>
<p>举例三：Smart Replication<br>把<em>Spray and Focus</em>的utility算法换成degree centrality</p>
<p>参考文献：<em>MOBILE AD HOC NETWORKING: THE CUTTING EDGE DIRECTIONS</em> Stefano Basagni, Marco Conti, Silvia Giordano and Ivan Stojmenovic</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/随建即连网络/" data-id="cimvy2edq000nc4xtftr9dv2u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hello-World-0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/01/29/Hello-World-0/" class="article-date">
  <time datetime="2016-01-29T11:41:01.000Z" itemprop="datePublished">2016-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/29/Hello-World-0/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>没错这只是一个Hello World。</p>
<p>目前来说这个博客打算用来放自己零零散散学的一些东西，没有什么值得看的。文章一般情况下会先写中文版，写不写英文版看心情＝ ＝。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/01/29/Hello-World-0/" data-id="cimvy2ecf0000c4xt0anugngv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Other/">Other</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/CS-35L/">CS 35L</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Other/">Other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/CS-35L/" style="font-size: 10px;">CS 35L</a> <a href="/blog/tags/Other/" style="font-size: 10px;">Other</a> <a href="/blog/tags/Research-Notes/" style="font-size: 20px;">Research Notes</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/04/11/P2POnSocialNorm-simulation1/">P2POnSocialNorm_simulation1</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/CS35L-March-28th/">CS35L March 28th</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/SEDUM/">SEDUM</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/PeopleRank/">PeopleRank</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/Multi-hop-vs-Two-hop-Routing-Modeling-Simulation-in-DTN/">Multi-hop vs Two-hop Routing Modeling &amp; Simulation in DTN</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Qianmeng Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/blog" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>