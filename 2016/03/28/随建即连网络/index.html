<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>随建即连网络 | Qianmeng&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="定义与名词解释
随建即连网络（Mobile Ad-Hoc Network, abbr. MANET）是无线随意网络（Wireless Ad-Hoc Network, abbr. WANET）的一种。它是一种以移动设备，通过无线链接，自我配置所形成的网络。在MANET之中的每个移动设备都可以自由移动，随时改变无线链接。每个移动设备节点都必须协助转发网络数据包，即使这个数据包是跟这个设备无关的。要创建">
<meta property="og:type" content="article">
<meta property="og:title" content="随建即连网络">
<meta property="og:url" content="http://qianmengchen.github.io/blog/2016/03/28/随建即连网络/index.html">
<meta property="og:site_name" content="Qianmeng's Blog">
<meta property="og:description" content="定义与名词解释
随建即连网络（Mobile Ad-Hoc Network, abbr. MANET）是无线随意网络（Wireless Ad-Hoc Network, abbr. WANET）的一种。它是一种以移动设备，通过无线链接，自我配置所形成的网络。在MANET之中的每个移动设备都可以自由移动，随时改变无线链接。每个移动设备节点都必须协助转发网络数据包，即使这个数据包是跟这个设备无关的。要创建">
<meta property="og:updated_time" content="2016-04-05T05:07:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随建即连网络">
<meta name="twitter:description" content="定义与名词解释
随建即连网络（Mobile Ad-Hoc Network, abbr. MANET）是无线随意网络（Wireless Ad-Hoc Network, abbr. WANET）的一种。它是一种以移动设备，通过无线链接，自我配置所形成的网络。在MANET之中的每个移动设备都可以自由移动，随时改变无线链接。每个移动设备节点都必须协助转发网络数据包，即使这个数据包是跟这个设备无关的。要创建">
  
    <link rel="alternate" href="atom.xml" title="Qianmeng&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Qianmeng&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/blog">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://qianmengchen.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-随建即连网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/03/28/随建即连网络/" class="article-date">
  <time datetime="2016-03-28T22:18:07.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      随建即连网络
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定义与名词解释"><a href="#定义与名词解释" class="headerlink" title="定义与名词解释"></a><a href="#u5B9A_u4E49_u4E0E_u540D_u8BCD_u89E3_u91CA" title="定义与名词解释"></a>定义与名词解释</h2><blockquote>
<p>随建即连网络（Mobile Ad-Hoc Network, abbr. MANET）是无线随意网络（Wireless Ad-Hoc Network, abbr. WANET）的一种。它是一种以移动设备，通过无线链接，自我配置所形成的网络。在MANET之中的每个移动设备都可以自由移动，随时改变无线链接。每个移动设备节点都必须协助转发网络数据包，即使这个数据包是跟这个设备无关的。要创建一个 MANET，最根本的挑战在于让每个移动设备都能够得到足够的信息，以协助保持网络信息的流通。<br>–引自<a href="https://zh.wikipedia.org/wiki/隨建即連網路">维基百科</a></p>
</blockquote>
<p>网络可以分为以下几种：</p>
<ol>
<li>Almost Connected Networks：顾名思义，相对连接比较密集的网络。大部分的pair都是相连的。传统传输协议仍然是主要的传输方法，但是因为网络中存在partition，需要用opportunistic forwarding来补充传统的path-based协议。</li>
<li>Sparse Networks：不存在大规模cluster，节点在大部分时间都是相互隔绝的，偶尔两节点相遇时进行信息传递，完全依赖于opportunistic forwarding。</li>
<li>Clusters or Connectivity Islands：呈现以不同cluster组成的结构，cluster内部连接紧密，不同cluster之间连接稀疏。</li>
</ol>
<p>网络有以下性质：<br>Mobility：基于某时刻网络的“快照”，网络的性质会如何变化。<br>Mobility Intensity：一定时间内信息传播的面积大小，面积越大，该节点相遇的节点更多，相遇时间越短。<br>Mobility Locality：一个节点可能会局限于一部分区域移动而很少光顾其他区域。<br>Mobility Regularity：出现周期性行为的期望。<br>Mobility Heterogeneity：每个节点的模式都非常不同。<br>Mobility Correlations：一部分节点呈现出相似的活动模式与地点，较高的关联度。</p>
<h2 id="几种常见的opportunistic-forwarding策略"><a href="#几种常见的opportunistic-forwarding策略" class="headerlink" title="几种常见的opportunistic forwarding策略"></a><a href="#u51E0_u79CD_u5E38_u89C1_u7684opportunistic_forwarding_u7B56_u7565" title="几种常见的opportunistic forwarding策略"></a>几种常见的opportunistic forwarding策略</h2><h3 id="策略一：Epidemic-Routing及其优化版本"><a href="#策略一：Epidemic-Routing及其优化版本" class="headerlink" title="策略一：Epidemic Routing及其优化版本"></a><a href="#u7B56_u7565_u4E00_uFF1AEpidemic_Routing_u53CA_u5176_u4F18_u5316_u7248_u672C" title="策略一：Epidemic Routing及其优化版本"></a>策略一：Epidemic Routing及其优化版本</h3><p>Epidemic Routing 基本策略：<br>每个节点储存其消息向量（message vector）来记录当下它记录了哪些信息。当两个节点相遇时，先比较两者的消息向量，然后交换非公共的消息内容。每次相遇完成后，两个节点都将持有完全相同的消息。<br>优点：能够保证找到最短的时空传输路径。<br>缺点：<br>    冗余（overhead，不知道怎么翻译）过高。epidemic routing的overhead可以以$\frac{N}{log_N}$增长至无限。<br>    如果节点的储存空间有限，epidemic routing不太现实。当储存空间不足时，新信息会将老信息在其传达完毕前踢出，导致congestion collapse。</p>
<p>改版一：IMMUNE_TX and VACCINE recovery schemes<br>在目标收到信息后，发出一个“抵消信息”来进行传播，然后消去网络中所有该信息的副本。因为抵消信息只需要储存信息的ID，其大小会小很多，因此可以很有效地减少overhead。</p>
<p>改版二：Gossiping or Randomized Flooding<br>在相遇时，以概率p来进行消息拷贝<br>或者<br>允许每个节点对该消息发放k份拷贝</p>
<p>改版三：Limited-time Flooding<br>设置一个epidemic routing时间门槛。在时间消耗完之前，先进行epidemic routing。之后停止所有拷贝，每个节点都只有在遇到目的地时才进行传递。</p>
<p>改版四：2-hop scheme<br>只有消息的源头可以创建拷贝，其余拷贝只有在遇到目的地时才传递消息。消息从起点到终点只进行两次跳跃（2-hop）。平均下来，该方法每个消息传递\frac{N-1}{2}次。</p>
<p>改版五：SLEF(Self-Limiting Epidemic Forwarding)<br> 随着congestion的升高，减少每个消息允许的跳跃次数(number of hops)。需要一个事实检测congestion的机制。</p>
<h3 id="策略二：Controlled-Replication-Schemes-Spray-and-Wait"><a href="#策略二：Controlled-Replication-Schemes-Spray-and-Wait" class="headerlink" title="策略二：Controlled Replication Schemes(Spray and Wait)"></a><a href="#u7B56_u7565_u4E8C_uFF1AControlled_Replication_Schemes_28Spray_and_Wait_29" title="策略二：Controlled Replication Schemes(Spray and Wait)"></a>策略二：Controlled Replication Schemes(Spray and Wait)</h3><p>Spray and Wait基本策略：<br>确保每条消息只被复制最多L次，不同的模型用不同的方法来达到这个效果。在Spray阶段，一般有如下两种传递方法：</p>
<ol>
<li>Source Spraying：只有消息的源头可以进行消息的复制传递，在进行L－1次复制之后，不再创建新的备份，只有在遇到目的地时才进行消息传递。</li>
<li>Binary Spraying：每一个节点在遇到一个不存有该消息的节点时，将自己拷贝数量的一半传递给对方，然后让对方以同样的方式进行传递。当拷贝数量为1时，除非遇到目的地，停止传递。</li>
</ol>
<p>注意：</p>
<ol>
<li>通常情况下Binary Spraying是更佳策略。Source Spraying一般用于消息依赖于源头的情况下。</li>
<li>如果网络有高mobility intensity和低的locality，Spray and Wait能达到和epidemic一样的传递时间而低至少一个数量级的传递数。</li>
<li>拷贝数上限L往往是可求解的。</li>
<li>高locality网络中，该策略的效率急剧降低。</li>
</ol>
<h3 id="策略三：Utility-based-forwarding"><a href="#策略三：Utility-based-forwarding" class="headerlink" title="策略三：Utility-based forwarding"></a><a href="#u7B56_u7565_u4E09_uFF1AUtility-based_forwarding" title="策略三：Utility-based forwarding"></a>策略三：Utility-based forwarding</h3><p>该模型基于以下几个思路：</p>
<ol>
<li>搜集并分析之前的相遇数据。</li>
<li>给每一个节点计算一个utility值，来表示该节点作为使消息离终点更近的传递者的能力。</li>
<li>在进行传递时，依据节点的utility采取不同的行为。</li>
</ol>
<p>模式一：Utility-based single-copy algorithms<br>当一个节点遇到一个比自己utility高的节点时，将消息传递出去，自己不留备份。</p>
<p>模式二：Contact-based Utility<br>Mobility是区分一个节点遇到之后节点的关键。</p>
<h4 id="模型一：Pair-based-Contact-Utilities"><a href="#模型一：Pair-based-Contact-Utilities" class="headerlink" title="模型一：Pair-based Contact Utilities"></a><a href="#u6A21_u578B_u4E00_uFF1APair-based_Contact_Utilities" title="模型一：Pair-based Contact Utilities"></a>模型一：Pair-based Contact Utilities</h4><p>以一个节点对作为单位，计算该两个节点相遇的Utility<br>考虑以下信息：</p>
<ol>
<li>距离上次相遇的时间</li>
<li>过去的相遇节点</li>
<li>一些其他的预测信息</li>
<li>该节点的活动规律</li>
</ol>
<h4 id="模型二：Contact-Graph-Utilities"><a href="#模型二：Contact-Graph-Utilities" class="headerlink" title="模型二：Contact Graph Utilities"></a><a href="#u6A21_u578B_u4E8C_uFF1AContact_Graph_Utilities" title="模型二：Contact Graph Utilities"></a>模型二：Contact Graph Utilities</h4><p>关键步骤：</p>
<ol>
<li>根据过去的节点的连接图来创建联络图</li>
<li>根据联络图来推断utility</li>
</ol>
<p>用一个二维数组 <strong>A(t)</strong>来存储在时刻t联络图的连接状态</p>
<ol>
<li>有权图：用一个标量函数来表示对于某时间段$[t_1, t<em>2]$点i与j之间的连接状态<br>$w</em>{ij} = f(A(t<em>{1})</em>{ij}, A(t<em>{1}+1)</em>{ij}, …, A(t<em>{2})</em>{ij})$</li>
<li>无权图：一方面，图中可以只存储连接的连与断（0或1）；另一方面，可以给$w_{ij}$设一个阀值，超过即为真。</li>
</ol>
<p>对于contact graph，有一些性质很关键：</p>
<ol>
<li>Community Structure</li>
<li>Small World：通常两个点之间存在十分短的路径，但是这并不代表这条路径能被很容易地找到。</li>
<li>Skewed degree distribution：有很强的heterogeneity。</li>
</ol>
<p>对于utility的计算，一般有以下几种：</p>
<ol>
<li>Centrality-based Utilities：<br>betweeness centrality被定义为穿过节点i的最短路径数量。但是此定义下的centrality难以计算，因为需要网络全局的数据。此外有计算简便的degree centrality，即该节点连接的节点数目。</li>
<li>The Similarity-based Utility：</li>
<li>Complete Social Network Analysis-based Schemes:<br>同时考虑了similarity（$Sim_i(d)$）和ego－centrality（$Bet_i$）<br>$U_i(d) = \alpha Sim_i(d) + \beta Bet_i$</li>
<li>Probabilistic Path-based Utilities<br>某个点适合做跳跃点，因为它在一条高实现概率的通路的起点。</li>
</ol>
<h3 id="策略四：混合Redundancy和Utility"><a href="#策略四：混合Redundancy和Utility" class="headerlink" title="策略四：混合Redundancy和Utility"></a><a href="#u7B56_u7565_u56DB_uFF1A_u6DF7_u5408Redundancy_u548CUtility" title="策略四：混合Redundancy和Utility"></a>策略四：混合Redundancy和Utility</h3><p>除了以上提到的几种基本策略，许多人也会想到将上述策略进行混合，取长补短，来达到更高效率。</p>
<p>举例一：Utility-based Flooding<br>只在相遇的节点达到一定Utility时才进行传递，又分为两种情况：</p>
<ol>
<li>绝对Utility门槛：$U<em>j(d) &gt; U</em>{thresh}$</li>
<li>相对Utility门槛：$U_j(d) &gt; U<em>i(d) + U</em>{thresh}$</li>
</ol>
<p>PRoPHET即是使用了Utility－based Flooding，它遵循下述规则：</p>
<ol>
<li>当某节点遇到目的地时，Utility增加。</li>
<li>未与目的地相遇时，Utility随时间减少。</li>
<li>当遇到另一个Utility不为零的节点时，Utility增加</li>
</ol>
<p>举例二：Spray and Utility-based Spraying<br>Spray的初期阶段时，先快速发放，然后再Wait阶段不进行wait，而是每次遇到utility比自己高的节点都将信息传递出去（自己不留拷贝）。<br><em>Spray and Focus</em>是其中一种重要的实现，该方法先进行binary spray，然后每当遇到比自己Utility高的节点都将消息传递出去。utility通过类似于PRoPHET的方式进行计算。</p>
<p>举例三：Smart Replication<br>把<em>Spray and Focus</em>的utility算法换成degree centrality</p>
<p>参考文献：<em>MOBILE AD HOC NETWORKING: THE CUTTING EDGE DIRECTIONS</em> Stefano Basagni, Marco Conti, Silvia Giordano and Ivan Stojmenovic</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://qianmengchen.github.io/blog/blog/2016/03/28/随建即连网络/" data-id="cimygmkc1000kojzf7h2kdu2s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2016/03/28/Introduction-to-MANET/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Introduction to MANET
        
      </div>
    </a>
  
  
    <a href="/blog/2016/01/29/Hello-World-0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/CS-35L/">CS 35L</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Other/">Other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Research-Notes/">Research Notes</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/CS-35L/" style="font-size: 15px;">CS 35L</a> <a href="/blog/tags/Other/" style="font-size: 10px;">Other</a> <a href="/blog/tags/Research-Notes/" style="font-size: 20px;">Research Notes</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/04/11/cs35L 0411/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2016/04/11/P2POnSocialNorm-simulation1/">P2POnSocialNorm_simulation1</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/CS35L-March-28th/">CS35L March 28th</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/SEDUM/">SEDUM</a>
          </li>
        
          <li>
            <a href="/blog/2016/03/28/PeopleRank/">PeopleRank</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Qianmeng Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/blog" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>